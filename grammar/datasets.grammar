loadConceptsParser
 description Load all concepts in all scroll files in a folder and remove any "import" statements.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell filePathCell
 javascript
  compile() {
   // A little hacky
   const { Disk } = require("jtree/products/Disk.node.js")
   const path = require("path")
   const {file} = this.parent
   const folder = path.join(file.folderPath, this.getWord(1))
   const ONE_BIG_FILE = Disk.getFiles(folder).filter(file => file.endsWith(".scroll")).map(fullPath => Disk.read(fullPath)).join("\n\n").replace(/import .+/g, "")
    this.parent.concat(ONE_BIG_FILE)
   //console.log(ONE_BIG_FILE)
   return ""
  }

printConceptsParser
 description Print the concepts in a page into an HTML table.
 cruxFromId
 extends abstractCommentParser
 javascript
   compile() {
   // A hacky but simple way to do this for now.
   const node = this.appendSibling("table \t", this.parent.file.compileConcepts("tsv"))
   const html = node.compile()
   node.destroy()
   return html
   }

writeConceptsParser
 cruxFromId
 catchAllCellType filePathCell
 description Compiles concepts to a delimited file and write to disk.
 extends abstractCommandParser

printTableParser
 description Print a tabular table in a page into an HTML table.
 cruxFromId
 extends abstractScrollParser
 javascript
   compile() {
    const node = this.appendSibling("table \t", this.tsv)
    const html = node.compile()
    node.destroy()
    return html
   }
   getTableByIndex(index) {
      const hit = this.root.file.tables[parseInt(index)]
      if (!hit)
        console.error(`Table "${index}" not found`)
      return hit
   }
   get table() {
     const index = this.getWord(1)
     if (index !== undefined)
        return this.getTableByIndex(index)
     if (this.next.isTabularData)
       return this.next
     if (this.previous.isTabularData)
       return this.previous.headerNode
    return this.getTableByIndex(0)
   }
   get tsv() {
    const firstNode = this.table
    const lastNode = firstNode.lastNode
    const aftertext = lastNode.childrenToString() // todo: we could be more specific and ignore comments
    let tableNode = firstNode
    let tsv = tableNode.getLine()
    while (tableNode.next.isTabularData) {
      tsv += "\n" + (aftertext ? tableNode.next.applyAftertext(aftertext) : tableNode.next.getLine())
      tableNode = tableNode.next
      if (tableNode === firstNode)
        break
    }
     return tsv
   }
   compileTextVersion() {
     return this.tsv
   }

tabularDataParser
 description Root lines with tabs are parsed as tsv data and printed as tables.
 cells anyCell
 pattern \t
 catchAllCellType anyCell
 extends abstractCommentParser
 javascript
  compileTextVersion() {
    return ""
  }
  get headerNode() {
    return this.isFirst ? this : this.previous.headerNode
  }
  compile() {
    return ""
  }
  get isFirst() {
    return !this.previous.isTabularData
  }
  get lastNode() {
    if (this.next.isTabularData && this.next.lineNumber)
      return this.next.lastNode
    return this
  }
  applyAftertext(aftertext) {
    const node = this.parent.appendLineAndChildren("* " + this.getLine(), aftertext + "\ntag none")
    const html = node.compile()
    node.destroy()
    return html
  }
  isTabularData = true
 example
  // The below lines will print a table
  printTable
  Index	Name
  1	Thermos
